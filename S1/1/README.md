### 메모리

<p>
메모리는 일련의 셀 형태로 구성되어 있다.<br />
물론, 실제로 저렇게 생겼다는 것은 아니고, 이렇게 이해해보자! 라는 것일 뿐이지만 말이다.<br />
하나의 셀은 1 byte(8 bit)로 구성되어 있으며, 모든 셀에는 우편번호 마냥 주소를 지니고 있다.
</p>

<img src="https://github.com/TaekGeunLee/study_CS/blob/master/readmeImg/S1_1-1.PNG" alt="S1_1-1" />

<p>
변수가 선언 될 때 마다 메모리의 셀이 사용된다.<br />
선언된 변수의 데이터 타입 마다 사용되는 셀의 갯수는 다르다.
</p>

### 포인터(pointer)

<p>일반 변수가 데이터 값을 할당한다고 하면, 포인터 변수는 데이터가 담긴 주소(address) 값을 담는다.</p>

<img src="https://github.com/TaekGeunLee/study_CS/blob/master/readmeImg/S1_1-2.PNG" alt="S1_1-2" />

<p>포인터 변수 내에 할당된 주소는 해당 메모리 셀에 담겨있는 데이터를 가리키게 된다.</p>

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int a = 30; // 일반 데이터
    int *ap = &a; // a 변수의 주소

    printf("general variable : %d ", a);
    printf("pointer : %d", ap);

    return 0;
}
```

<p>
변수 이름 앞에 *(특수기호)를 씀으로써 포인터 변수를 선언한다.<br />
포인터 변수 내에는 메모리의 주소를 넣는데, 대상 변수 앞에 세미콜론(&)이 붙인 것은 주소 값이다! 라고 생각하자.<br />
(물론 변수 이기에 일반 데이터도 넣을 수 있다.)
</p>

```c
printf("ap : %d ", ap); // 주소 값이 출력.
printf("*ap : %d", *ap); // 주소가 가리키고 있는 데이터가 출력.
```

<p>
특수기호(*)를 붙이냐 마냐에 따라 주소 값을 사용할 지, 해당 주소에 담긴 데이터를 사용할지 에 대해 판단할 수 있다.<br />
이것은 일반 변수가 아닌 포인터 변수를 이용해 데이터를 다룰 수 있다는 말이다.<br />
이를 이용한 예제를 참고해보도록 하자.<br />
(ex1.c) 참고.
</p>

### 포인터 배열

<p>
결론 먼저 말하자면, 배열의 이름은 포인터 변수이다.<br />
(배열 그 자체가 포인터 변수라는 것은 아니다. 착각하지 말 것.)
</p>

```c
int arr[15];
```
<p>
예를 들어 이런 식으로 배열을 선언했을 때 메모리의 빈 공간들을 사용하게 된다. (15칸의 셀을 쓰므로 총 60byte를 쓰게 됨.)<br />
이때 배열로 사용한 셀 이외에 선언한 배열의 이름을 지닌 포인터 변수가 자동으로 생성된다.<br />
이렇게 생성된 포인터 변수는 배열의 첫 번째 인덱스에 해당되는 칸의 번지를 저장하게 된다.
</p>

<img src="#" alt="S1_1-3" />

<p>
이러한 특징을 활용한 예제 ex2.c를 확인해보자.<br />
어떤 함수의 매개변수로 배열을 받는다고 가정을 했을 때, 보통 arr[]로 쓰겠지만,
*arr로 받아도 문제 없다는 것이다.
</p>

### arithmetic 연산

<p>
이전 구절대로라면 arr[0] = *arr 인 것이다.<br />
또한, arr[i] = *(arr + i) 이다. (*arr + i 가 아니다!)<br />
이렇게 주소 값에 수를 연산하는 방식을 arithmetic 연산 이라고도 부른다.
</p>

<p>
ex3.c에서 그 활용 예시를 보여주고 있다.<br />
만약 int 형 배열을 생성하였을 경우 하나의 인덱스 마다 메모리의 4칸 셀을 사용하게 된다.<br />
이 때 주소 값에 1를 더했을 경우 주소 값이 +1 되는 것이 아니라 각 인덱스가 차지하는 크기인 +4가 되는 것이다.
</p>

### 동적 메모리 할당(dynamic memory allocation)

<p>
코드 상에 직접 변수를 선언하지 않고, 프로그램에게 요청을 하는 것으로 메모리를 사용한다.<br />
이러한 작업이 동적 메모리 할당 방식이다.
</p>

<p>
여러 함수가 있지만, malloc() 함수를 이용해 동적 메모리 할당을 요청할 수 있다.
</p>

```c
int *p;
p = (int *)malloc(40); // 변수형을 지정하지 않고도 사용 가능하다. 이때는 void 타입이 리턴된다.

p[0] = 1;
p[1] = 2;
/// ...
```

<p>
위의 예제에서 포인터 p를 선언하고, malloc()를 이용해 메모리의 할당을 요청했다.<br />
함수의 매개변수로 할당할 메모리의 크기(byte)를 지정한다.<br />
위의 예제대로라면 int 타입의 10칸 짜리 배열이 생성될 것이다.<br />
해당 예제는 ex4.c를 참고하도록 하자.
</p>

### 배열 크기 늘리기

<p>
이전 구절에서 배운 것을 활용하여 이미 정해지 배열의 크기를 늘릴 수 있다.<br />
다음 예제를 살펴보자.
</p>

```c
int *arr = (int *)malloc(4*sizeof(int)); // sizeof() : 인수로 받은 자료형의 크기를 리턴.
// 도중에 배열의 크기가 모자라!!

int *tmp = (int *)malloc(4*sizeof(tmp));

arr = tmp
```
<p>
arr 배열의 크기를 늘리기 위해 tmp 배열을 선언했다.<br />
이게 어떤 원리냐면, 포인터 변수 *arr이 가리키고 있는 대상 배열을 *tmp가 향하고 있는 배열로 바꾸는 것이다.<br />
그림으로 나타내면 다음과 같다. 
</p>


<img src="#" alt="S1_1-4" />

<p>해당 예제는 ex5.c에서 참고할 것.</p>








